#include<stdio.h>
#include<string.h>

//操作符



//算术操作符 + - * / %
//主要练习 / %
//int main()
//{
//	// % 取余符号   符号两边都必须是整数
//	int ret,ret1,ret2;
//	float ret3;
//	ret=2 % 5;
//	ret1=6 % 5;
//	ret2= 5 / 3;
//	ret3=5.0/3;
//	printf("ret=%d\nret1=%d\n",ret,ret1);// 2   1
//
//	// / 除号  符号两边都是整数，结果为商，要做除法运算，符号两边必须至少有一边是float or double 浮点类型
//
//	
//	printf("ret2=%d\nret3=%f\n",ret2,ret3);// ret2=1  ret3=1.666667
//	return 0;
//}


//移位操作符(对二进制进行移位)  << >>

//int  main()
//{
//	int a=4;
//	int new1,new2,new3;
//	int b=-4;
//	
//	//左移：左边抛弃，右边补0(左移不分算术左移 or  逻辑左移 )
//	
//
//
//	new1=a<<2;
//
//	//4的二进制:00000000000000000000000000000100
//	//左移：    00000000000000000000000000010000
//	//左移简单算法：a* 2^n次方(n为左移的数)
//	printf("new1=%d\n",new1);
//
//	//右移分为：算术右移(右移前面补符号位) 和  逻辑右移动(右移前面补0)    VS环境下是默认算术右移
//	//实际上也就是当是符号数的时候，分算术右移 和 逻辑右移
//
//	new2=a>>2;
//	//4的二进制:00000000000000000000000000000100
//	//右移：    00000000000000000000000000000001
//	// 对于正数，右移简单算法:a / 2^n次方(n为右移的数)
//	printf("new2=%d\n",new2);
//
//
//	new3=b>>2;
//	//-4的二进制:10000000000000000000000000000100  原码
//	//	-4：	 11111111111111111111111111111011  反码
//	//	-4：	 11111111111111111111111111111100  补码
//	//计算机在内存中的计算都是采用补码的形式，正数的原码 反码 补码 都一样
//	// 右移后:   11111111111111111111111111111111
//	//打印是肉眼可见的：用的是原码打印
////右移后的原码:  10000000000000000000000000000001   -1
//	printf("new3=%d\n",new3);
//	return 0;
//}



//位操作符 &(与) |(或)  ^(异或)  位操作符是对二进制的每一位进行与 或 异或操作  
//int main()
//{
//	int a,b,c,d,ret,ret1,ret2;
//
//
//	a=4;
//	b=3;
//	c=-1;
//	d=3;
//	// & 操作  操作两边必须是整数
//	ret= a & b;
//	ret1=a | b;
//	ret2= a ^ b;
//	//计算机计算统一用补码
//	// a的二进制:00000000000000000000000000000100   (正数原码 反码 补码都一样)  
//	// b的二进制:00000000000000000000000000000011
//	//按位&:     00000000000000000000000000000000
//	//按位|:     00000000000000000000000000000111
//	//按位^:     00000000000000000000000000000111   相同为0  不统为1
//	printf("ret=%d\nret1=%d\nret2=%d\n",ret,ret1,ret2); //0  7  7
//	printf("\n");
//	ret= c & d;
//	ret1=c | d;
//	ret2=c ^ d;
//	//c的二进制:10000000000000000000000000000001 原码
//	//          11111111111111111111111111111110 反码
//	//          11111111111111111111111111111111 补码
//
//	//d的二进制:00000000000000000000000000000011 原码
//
//	//按位&:    00000000000000000000000000000011 补码-------00000000000000000000000000000011     3
//	//按位|:    11111111111111111111111111111111 补码-------10000000000000000000000000000001    -1
//	//按位^:    11111111111111111111111111111100 补码-------10000000000000000000000000000100    -4
//	printf("ret=%d\nret1=%d\nret2=%d\n",ret,ret1,ret2); 
//
//	return 0;
//}
//


//赋值操作符 : =  += -= *= /= %=   ....

//int main()
//{
//	int a;
//	//赋值操作
//	a=5;
//	printf("a=%d\n",a);//5
//	a+=5; // a+=5  等价于 a=a+5
//	printf("a=%d\n",a);//10
//	//其他赋值操作符同理
//
//	return 0;
//}



//单目操作符:  !  - + &(取地址) sizeof() ~  -- ++ *  (类型) 转换

//
//int main()
//{
//	int a=5;
//	int b=0;
//	int* p;
//	int c=5;
//	char arr[]="as1asad";
//	// 逻辑取反   真为假  假就为真
//	printf("%d %d\n",!a,!b); // 0  1
//
//	p=&a;//把a的地址存在指针变量p中
//	printf("%p\n",p);
//
//	//sizeof 算长度  单位为字节  sizeof是操作符 不是函数
//	printf("长度为:%d\n",sizeof(a));
//	//省略括号写法  如果是变量可以省略  类型不能省略
//	printf("长度为:%d\n",sizeof a);
//	printf("长度为:%d\n",sizeof arr);//8  把字符串的'\0'也算进去了。
//
//	// ~ 对二进制位进行取反   不管是不是符号位，每一位都要进行取反操作
//	//a的二进制：00000000000000000000000000000101               补码(正数原码 反码 补码相同) 5
//	//取反：     11111111111111111111111111111010               补码
//	//取反原码:  10000000000000000000000000000110               原码   -6
//	printf("a取反：%d\n",~a);
//
//	// ++ --单目操作符    
//	//分为前置++和后置++  分为前置--和后置--
//	//前置++ :先++在使用，后置++:先使用再加    减减同理
//	//a=5
//	b=++a;
//	printf("b=%d a=%d\n",b,a);//6  6
//	//c=5
//	b=c++;
//	printf("b=%d a=%d\n",b,c);// 5 6
//
//	// *间接访问操作符 出现在指针里，解引用
//	printf("%d\n",*p); //6 p存放的是a的地址，a的值改变，*p的值也会改变
//	// 类型转换
//
//	printf("%f\n",(float) a); //6.00000
//	return 0;

//}



//关系操作符 > >= < <= != ==   比较简单

//int main()
//{
//	int a=5;
//
//	if(a > 5)
//		printf("大于5\n");
//	else
//		printf("小于等于5\n");
//
//	return 0;
//}


//逻辑操作符 && ||	 区分逻辑与和按位与   逻辑或与按位或


//int main()
//{ 
//
//	//特点： &&有假即为假，不会进行后续的计算  ||有真即为真，不会进行后续的计算
//	int a,b,c;
//	a=5;
//	b=3;
//	c=0;
//	if ((a && b )> 0)
//		printf("真\n");
//	else
//		printf("假\n");
//	if ((a && c )> 0)
//		printf("真\n");
//	else
//		printf("假\n");
//
//
//	return 0;
//}


//条件操作符(三目操作符) exp1?exp2:exp3   exp1成立 使用表达式exp2,不成立使用表达式exp3

//int main()
//{
//	int a,b,c;
//	a=5;
//	b=6;
//	c=a>b?1:2;
//	printf("%d\n",c); //2
//
//	return 0;
//}


//逗号表达式exp1,exp2,exp3,
//int main()
//{
//	
//	int a,b,c,d,e;
//	a=1;
//	b=2;
//	c=3;
//	//逗号表达式特点，从左到右依次计算，但是只取最后一个表达式
//	d=(a=1,b=2,c=3);
//	printf("d=%d\n",d);  //3
//	//逗号表达式特点，从左到右依次计算，但是只取最后一个表达式   a=1,b=2,c=3
//	e=(a++,b++,c++);
//	printf("a=%d b=%d c=%d e=%d\n",a,b,c,e); //2 3 4 3
//	return 0;
//}


////下标引用、函数调用、结构体成员访问操作符   [] () .
//void test()
//{
//	int a;
//	a=5;
//	printf("a=%d\n",a);
//
//}
//struct Book
//{
//	char name[20];
//	int price;
//};
//int main()
//{ 
//	//初始化结构体
//	struct Book b1={"C语言",55};
//	//定义结构体类型指针
//	struct Book* pb;
//
//	int num[6]={0,1,2,3,4,5};
//	int i,sz;
//	sz=sizeof(num)/sizeof(num[0]);
//	pb=&b1;
//	printf("%d\n",sz);
//	// []数组访问符
//	for(i=0;i<sz;i++)
//	{
//		printf("num[i]=%d\n",num[i]);
//	
//	}
//	//()函数调用
//	test();
//
//	//. 结构体成员访问
//	printf("name：%s\n",b1.name);
//	printf("price:%d\n",b1.price);
//	printf("\n");
//	// *  ->指针访问成员   
//	printf("name：%s\n",(*pb).name);
//	printf("price:%d\n",(*pb).price);
//	printf("\n");
//	printf("name：%s\n",pb->name);
//	printf("price:%d\n",pb->price);
//	return 0;
//}


//表达式求值

//表达式求值的顺序一部分是由操作符的优先级和结合性决定的
//同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型


// 两大类型： 隐式类型转换
//C的整型算术运算总是至少以缺整型类型的精度来进行的
//为了获得这个精度，表达式中的字符和短整型操作上在使用之前会被转成普通整型，这种称为整型提升

//各种小于Int类型长度的都要先转成int类型  如：char  short

//整型提升：按照变量的数据类型的符号位来提升的

//int main()
//{
//	 char c1=-1;
//	 char c2=1;
//	 char c3;
//	 char c4=3;
//	 char c5=127;
//	 char c6;
//	 //整型提升：按照变量的数据类型的符号位来提升的
//
//	 //负数的整型提升
//	 //char 只有8个bit,二进制为:11111111 补码
//	//整型提升后，提升为4个byte：11111111111111111111111111111111 补码
//	 
//
//
//	 //正数的整型提升
//	 //char 只有8个bit,二进制为:00000001  补码 
//	 //整型提升后，提升为4个byte:00000000000000000000000000000001
//
//	 //无符号整型提升，最高位补0 
//
//	 //c1整型提升:11111111111111111111111111111111
//	 //c2整型提升:00000000000000000000000000000001
//	 // 相加     :1(溢出,丢弃)00000000000000000000000000000000         
//	 //最终结果  :00000000000000000000000000000000  补码
//	 c3=c1+c2;
//	 printf("c3=%d\n",c3); // 0
//
//	 //c4 3:  00000011  截断
//	 //c5 127:01111110  截断
//	 //c4整型提升:00000000000000000000000000000011  补码
//	 //c5整型提升:00000000000000000000000001111111  补码
//	 // 相加      00000000000000000000000010000010  补码
//	 // 截断(8bit):10000010   补码
//	 //            10000001   反码
//	 //            11111110   原码   -126
//	 c6=c4+c5;
//	 printf("c6=%d\n",c6);
//	 return 0;
//}


//算术转换
//如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，
//否则操作就无法进行，下面的层次体系称为寻常算术转换
//long double
//double
//float
//unsigned long int
//long int
//unsigned int
//int 
//如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运算

//int main()
//{
//	float f=3.14;
//	int num=f;
//	
//
//	printf("%d\n",num);
//
//	return 0;
//}

//操作符的顺序 看表 省略


