#include<stdio.h>
#include<stdlib.h>
#include<string.h>

//汉诺塔问题
//int i=1;
//void Hanoi(int n,char A,char B,char C)
//{
//	if(1==n)
//	{
//		printf("第%d步：%c----->%c\n",i,A,C);
//		
//		i++;
//	
//	}
//	else
//	{
//		Hanoi(n-1,A,C,B);//第一大步，A上的n-1个盘子移动到B上，  剩最大的一块移动到C上
//		printf("第%d步：%c----->%c\n",i,A,C);
//		i++;
//		Hanoi(n-1,B,A,C);//第二大步，B上的n-1个盘子移动到A盘上，剩最大的一块移动到C上
//	}
//		
//}
//
//int main()
//{
//	int n;
//	printf("请输入要多少个盘子:>");
//	scanf("%d",&n);
//	getchar();
//	Hanoi(n,'A','B','C');
//
//
//	return 0;
//}


//青蛙跳台
//青蛙跳台阶本质类似斐波那契数问题
//青蛙跳台阶（1次可以跳一个台阶，1次也可以跳2个台阶，这只青蛙要跳到第n个台阶，有多少种跳法）
/*

1.如果有1个台阶只有1种跳法
2.如果有两个台阶，青蛙第一次可以选择跳一个，也可以选择跳两个。假如选择跳一个，之后只有一次选择跳完剩下的一个台阶这是一种跳法。假如选择跳两个是另外一种跳法，所以两个台阶有两种跳法
3.如果有三级台阶，第一次青蛙还是可以选择跳一级台阶或者两级。假如第一次选择跳一级台阶，接下来剩余两级台阶可以按照2步骤跳则有两种可能。假如第一次选择跳两级，还剩下一级台阶，按照步骤1的跳则有一种可能。所以三级台阶有三种跳法
4.如果有四级台阶，青蛙第一次依旧可以选择跳一级台阶或者两级。假如第一次跳了一级台阶，还剩下三级台阶我们可以按照3步骤来算有多少种跳法则为三种可能。假如第一次跳了两级台阶，还剩下两级台阶，按照步骤2跳法则有两种可能。所以四级台阶有五种跳法
…
…
而要求跳n个台阶有多少种跳法，就要知道跳n-1个台阶和跳n-2个台阶有多少种跳法，而要知道跳n-1个台阶和跳n-2个台阶有多少种跳法就要知道跳n-3，n-4个台阶有多少种跳法…以此类推，最终得到结果。这样分析很容易就可以想到用递归来求解。就好像一个变种的斐波那契数列。
――――――――――――――――


*/

//青蛙跳台阶
int Jump(int n)
{
	if(1==n)
		return 1;
	else if(n==2)
		return 2;
	else
		return Jump(n-1)+Jump(n-2);
}

int main()
{
	int n,ret;
	printf("请输入要跳几层:>");
	scanf("%d",&n);
	getchar();

	ret=Jump(n);
	printf("青蛙跳台一共有%d种跳法\n",ret);
	return 0;

}